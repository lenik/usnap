

- 最终二进制
	- 在最终编译过程中，编译器处理的是最终二进制。
	  [哈希串]和诸如_base64编码串面对的都是最终二进制。

- 编码方式
	- 必须说明文本使用的编码。可以有几种方法来确定文本编码，
		- 文件头: 标准的 txt 头部字节，如记事本采用的方法，用文件的开头两字节表示。
		  这种方式主要用于标记 ascii/utf8/unicode 等宏观类型。
		- 元语法: XML 风格的字符集描述文本。但事实上 xml 也无法摆脱文件头的存在。
		- 自动判断: 通过使用直方图等技术自动判断字符编码方式。
		- 外部说明: 比如通过扩展名、数据库中的描述等。
		- epfs结构: 文本/代码及各种信息将被存放在 epfs 中，
		  epfs 关于文本的结点含有描述编码的子结点。
		- 明确指定: 用户明确说明文本所采用的编码方式。

	- 有一些编码是互相兼容、或者部分兼容的，比如 ascii 与 unicode、utf8 等。
	  事实上大部分字符集的最前面若干部分都是兼容的，包括 [0-9a-zA-Z]等。

	- vc6 处理方法：
		- 支持 ascii
		- 不支持 utf8, (乱码)
		- 对于 unicode/unicode-big 将会启动记事本将其打开。
	- 编码方式：
		- ASCII		(无)
		  单字节 中文2字节
		- UTF-8		EF BB BF	111011111011101110111111
		  单字节 中文3字节
		- Unicode	FF FE		1111111111111110
		  双字节
		- Unicode-Big	FE FF		1111111011111111
		  双字节

- 分析器的字符集解决方案
	- 转存变质：SaveAsCoursed 脚本在转存时可能会发生字符集转换，比如将 ascii 转存至 unicode，
	  因此，分析器对应也有 2 种模式：二进制模式，文本模式。

	  实际上，文本模式类似于在二进制模式前面加入一层预处理。

	- 内外模式
	  文本信息存在着两个层面，一层是存储方式。存储方式限定了文本信息表示
	  抽象文本内容的能力，比如用 Unicode 存储方式可以获得比较大的表示范围。
	  另一层是表示方式，也就是希望分析器将其表示为何种字符集。

		# x@a.coding (UTF8,GB2312) as (Unicode)
		# ... 文本段 ...
		表示文本段(或整个文本)是以 Unicode 形式存储的，而在分析时则采用
		UTF8,GB2312 的编码方式来处理。这过程中，分析器将自动完成转换过程。

	- 采用 epfs 作为存储支持
	  完美的结构性作为解决 epfs 具特殊的意义，因为从减轻分析器的负担方面看，
	  epfs可以通过数据过滤器来完成 内外模式的转换。

	- 默认与兼容方式
	  对于没有声明默认方式以及一般的文本文件需要考虑兼容问题。
	  无疑，没有声明编码方式可能会引起 转存变质 问题。
	  但事实上一般人们总是习惯于以一种方式来处理文本，VC 即使如此。
	  而且由于语言间（区域化）发生转换的可能性比较小（如果采用Unicode，则不会发生这种问题），
	  因采用ASCII/Unicode作为默认方式对付一般应用已经足够。


- 单元切分
	- 单元是作为文本分析中的用于表示一个字符的单位。

	- ASCII