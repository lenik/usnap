

- 其中一个关键性问题是多个语法状态共存时怎么互相关联起来

	- 1
		# x@a.m* #define name val
		# x@a.layout ./abc {
		# x@a.m* #define name val2
		# x@a.layout }
	- 2
		# x@a.m* #define name1 val
		# x@a.m* .... codes ....
		# x@a.m* #define name2 val {
		# x@a.m*   .... codes ....
		# x@a.m*   #define name2 val_2 {
		# x@a.m*     .... codes ....
		# x@a.m*   }
		# x@a.m* }

	-

- 一个语法分析器中，有若干并列分析器组成，其中几个肯定会有对相同句子的不同分析方法。
  在实例脚本中一方面可以指定一段文本由哪个分析器分析，而另一方面则不会有这种指定。
  这就要求语法描述中，不同分析器之间对同一个句子的分析器裁决。
  可以使用抢占裁决方式。

- 要求裁决的歧义即规约冲突的裁决，有两种主要类型的信息：
	- 默认/其余字串，"."
	- 指定字串，比如 "/*" .* "*/" 之类
  分析器之间都有对同样串的解释，这就需要优先级裁决。


- 正则表达式
	- 所谓“正则表达式等价于自动机”，这里的正则指的是正则文法（即3型chomsky文法）
	  实际应用的正则表达式是属于正则文法的。
	- 为了确定条件，仅仅正则表达式是远远不够的。G语言本身也许可以用正则表达式
	  完全描述，但就和语法系统可以指定 BNF 系统一样，条件表达式也可以指定。
	- /.../ 总是正则表达式。
	-

- 其它形式的表达式
	- 图表达式
		- 1
			---------
			---   ---
			- -   - -

		- 2
	- ...

-

- 通过如果实例脚本指定分析器，如
	s1: stmt...
	s2: stmt...
	s2: stmt...
	s1: stmt...
	s2: stmt...
	s1: stmt...
	s2: stmt...
	s2: stmt...
	s1: stmt...
  那么事实上需要 3 个分析器： s0 分析脚本中的 "s1:", "s2:" 等前缀，而 s1, s2 则分析
  具体的脚本内容。

	- 1 子段分析
		s0 {
			s1_context ::= "s1:" context
				$$ = $2, s1.lex->append($$)

			s2_context ::= "s2:" context
				$$ = $2, s2.lex->append($$)
		}

		s1 {
			sym ::= tokens...
		}

		s2 {
			sym ::= tokens...
		}

		- 对于 context 部分内容，要求 s0 先把它提取出来，然后再定向送至
		  s1或s2，这样如果分析器层次多了的话会导致重复分析。
		  另一方面，在某些情况下比如 x@a 注释扩展，宿主语言并不需要参与
		  到注释的分析中。（这会导致宿主语言的纯粹性）

	- 2 环境切换自动机(1)
		[auto] s0 {
			"s1:" p_current_lex = s1.lex
			"s2:" p_current_lex = s2.lex
			~: ignore
		}

		- 仍旧不能摆脱重复分析之嫌，而且词法分析导致分析器设计困难。

	- 3 环境切换自动机(2)
		[auto] s0 {
			"s1:" default_processer = s1
			"s2:" default_processer = s2
		}

		- 通过调整裁决(歧义)优先级来实现切换。
		- 依靠裁决优先来完成多语言设计会导致不同分析器之间关系错综复杂，
		  大大破坏 oop 设计模式 （虽然这是 x@a 所提倡的，但也要适度）。
		- 在这种嵌套结构下，无论如何，s1/s2 需要一种切换回 s0 的方法，可以
		  用事件通知机制，或者结束符机制，都需要在 s1/s2 插一脚，相较而言
		  都没有子段分析那么自然。
		- 从实现细节看，语法分析比如 LALR(1) 也是用自动机来实现的，因此 s0
		  可以直接跳转到语法分析器的自动机上。但写起来很复杂。

	- 4 综合
		- 子段分析
		- 默认流切换
		- 调整裁决

	-

- 需要设计分析器的对象结构，这样能够：
	- 分析器调用者可以设置一些初始配置信息，以及动态调试
	- 分析器不仅可以作为脚本的分析，也可以直接向调用者到处原始分析结果（分析树）
	  也可以方便和 EPFS 结合。
	- 分析器语法脚本中可以直接包含控制分析器的语句，比如各种切换操作。
