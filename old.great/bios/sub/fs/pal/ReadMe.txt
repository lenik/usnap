

	路径分析库


--------------------------------------------


我想了半天也没想好，到底采用面向对象还是函数集合+数据结构？


--------------------------------------------

面向对象的缺点：还没有找到缓存的通用方法？

	如果使用面向对象设计路径分析类，那么这个类的 FULLPATH 属性
设置将使得 FULLPATH 被切割成小块小块，然后当用户GET 小块小块的
 PATHSEGS 数组元素时，这些小块可能是动态生成的，借用了缓存的方法
使得动态的东西变成了静态的东西。在这个典型的情况下，如何设计一个
通用的缓存管理方法，使得在 PAL 中不必为大量的数据设计各自的缓存空间？

	[如果找到了，那么使用OOP无疑了]
---------------------------------------------

其实使用函数集合+数据结构也同样不能避免这个问题。
但是有个好处就是使调用者养成接受返回的所有数据的麻烦的好习惯。

---------------------------------------------

前面提到，PAL有一个功能，就是将输入属性FULLPATH切割成小块小块的PATHSEGS。
在PAL中，如果只有一个对象，只有这个功能，那么显然它具有下面的I/O关系：

		   +-------------+----o SEG1
	FULLPATH o-|	         |----o SEG2
	           |             |----o ....
		   +-------------+----o SEGn

如果有多于一个对象，那么应当将每个对象看成是独立的部分。
如果一个对象中有不止一个简单的I/O关系，那怎么表示?

---------------------------------------------

理论的解决方案

	目前的矛盾发现，无论是COM、以及其它的一些组件规范，都缺少一些
必要的辅助信息。这些信息与程序代码一起，构成了整个“软件”，这个“软件”
其实是一个组件或库。像 COM，为了使组件支持信息描述，要求组件需要实现一个
ITypeInfo接口，在调度上也有类似的，如果组件需要调度，那它要实现IDispatch
接口，而不同语言需要不同的组件文件，COM在实现多国语言上的缺点是：

	在一个组件文件内部，是只能实现一个语言调度。
	如果需要一个文件同时支持多国语言调度，就做不到了。
	如一定需要多国语言支持，只好编译各国对应的语言的组件了。

	解决方案是：
	通过epfs，将组件和组件信息一并存入！！！！！！

	这简直太优美了！

	不过，COM 的接口支持方案也有很好的地方。
---------------------------------------------

用epfs实现的调度举例

	这里的调度是广泛意义上的调度，不限于导出函数或COM。

	1）导出函数
	math.epfs
		|
		|- math.dll
		|
		+- dispatch
			|
			|-codepage 902
			|
			...
			|
			+-codepage 802

		其中codepage 802是这样的一个纯文本文件：
		（对于文本文件的统一编码，还需要一番研究！）

			正弦 --> sin
			余弦 --> cos
			……

		也可能是这样：
			正弦 --> @16
			余弦 --> @17

		如果math.dll是一个COM组件，那又有变化：一种可能math.dll本身支持调度，
		另一种可能math.dll的调度是通过epfs扩展的：

			[[ 这个扩展现在还比较模糊，以后再分析吧！]]

	2）类型信息
	math.epfs/
		|- math.dll
		|- dispatch/...
		+- typeinfo/
			|
			|-codepage 902
			|
			...
			|
			+-codepage 802

		这里的codepage 802则是描述整个dll、然后可能是各个函数的类型信息。
		也是纯文本文件，大致同上，也可分为函数和COM的区别。

--------------------------------------------------

继续前面部分。考虑i/o流中间处理组件。为了图化，可能组件/某个函数中
有一些是输入参数，另一些是输出参数等等。
在使用epfs实现时，为了描述这些信息，加一个 iounit 结点（与dispatch、typeinfo并列）

	iounit/
		...

具体定义留待以后。
